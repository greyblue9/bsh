
public static Triple addProperty(String name, String type, CtClass ct, Collection memberSrc) { String src = null; CtField cf = null; CtMethod cm_get = null, cm_set = null; String ucfirstName = String.format("%c%s", Character.toUpperCase(name.charAt(0)), name.substring(1)); for (String mdName: new String[]{ "get".concat(ucfirstName), "set".concat(ucfirstName) }) { javassist.bytecode.MethodInfo mi_exist = ct.getClassFile().getMethod(mdName); if (mi_exist != null) { ct.removeMethod(ct.getMethod(mi_exist.getName(), mi_exist.getDescriptor())); if (ct.getClassFile().methods.remove(mi_exist)) { System.err.printf("Removed existing method: %s\n", mi_exist); mi_exist = null; }; }; };  Map fieldMap = RealArrayMap.toMap(Arrays.asList(StringUtils.join(ct.getClassFile().getFields(), '\n').matchLines("^([^ ]+) (?:.+ |)([^ ]+)$"))[0]); if (fieldMap.containsKey(name)) { ct.removeField(ct.getDeclaredField(name)); }; ct.addField(cf = CtField.make(src = String.format("private %s %s;", type, name), ct)); memberSrc.add(src); ct.addMethod(cm_get = CtNewMethod.make(src = String.format("public %s get%c%s() { return %s; }", cf.getType().getName(), Character.toUpperCase(cf.getName().charAt(0)), cf.getName().substring(1), cf.getName()), ct)); memberSrc.add(src); ct.addMethod(cm_set = CtNewMethod.make(src = String.format("public void set%c%s(%s value) { %s = value; }", Character.toUpperCase(cf.getName().charAt(0)), cf.getName().substring(1), cf.getType().getName(), cf.getName()), ct)); memberSrc.add(src); return Triple.of(cf, cm_get, cm_set); }

public static Triple addProperty(String name, String type, CtClass ct) { java.util.List srcList = new java.util.ArrayList(); return addProperty(name, type, ct, srcList); }

