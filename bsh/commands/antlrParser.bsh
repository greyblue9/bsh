org.antlr.v4.Tool tool = new org.antlr.v4.Tool(); String grammarStr = FileUtils.readFileToString(new File("/external_sd/_projects/sdk/java_antlr/src/Java.g4")); org.antlr.v4.tool.ast.GrammarRootAST groot = tool.parseGrammarFromString(grammarStr); org.antlr.v4.tool.Grammar grammar = tool.createGrammar(groot); tool.process(grammar, false); String[] tokenNames = grammar.getTokenNames(); org.antlr.v4.tool.LexerGrammar lexGrammar = grammar.getImplicitLexer();     org.antlr.v4.runtime.atn.ATN atn = grammar.getATN(); LinkedHashMap indexPredMap = grammar.getIndexToPredicateMap(); org.antlr.v4.runtime.VocabularyImpl vocab = grammar.getVocabulary(); org.antlr.v4.runtime.misc.IntervalSet tokenTypes = grammar.getTokenTypes(); org.antlr.runtime.CommonTokenStream tokStream = grammar.getTokenStream(); java.util.LinkedHashSet stringLiterals = (LinkedHashSet) grammar.getStringLiterals(); String recognizerName = grammar.getRecognizerName(); List<String> lexRuleNames = Arrays.asList(lexGrammar.getRuleNames()); Map ruleMap = new TreeMap(); String[] ruleNames = grammar.getRuleNames(); int ruleCount = ruleNames.length; for (int i=0; i<ruleCount; ++i) { org.antlr.v4.tool.Rule rule = grammar.getRule(i); String ruleName = rule.name; ruleMap.put(ruleName, Pair.of(Integer.valueOf(i), rule)); System.err.printf("%d: %s: %s\n", i, ruleName, rule); };  org.antlr.v4.runtime.CharStream cs = new org.antlr.v4.runtime.ANTLRInputStream(new BufferedReader(new InputStreamReader(new FileInputStream(new File("/external_sd/_projects/sdk/bsh/trunk/src/org/d6r/Dumper.java"))))); org.antlr.v4.runtime.LexerInterpreter lex = grammar.createLexerInterpreter(cs); org.antlr.v4.runtime.TokenStream tokenStream = new org.antlr.v4.runtime.CommonTokenStream(lex); org.antlr.v4.runtime.ParserInterpreter parser = grammar.createParserInterpreter(tokenStream); org.antlr.v4.runtime.atn.ParserATNSimulator atnSimulator = (org.antlr.v4.runtime.atn.ParserATNSimulator) parser.getInterpreter(); atnSimulator.setPredictionMode(org.antlr.v4.runtime.atn.PredictionMode.SLL);  Pair enterRulePair = ruleMap.get("compilationUnit"); int enterRuleIndex = enterRulePair.getKey().intValue(); org.antlr.v4.tool.Rule enterRule = enterRulePair.getValue();  org.antlr.v4.runtime.ParserRuleContext cuctx = parser.parse(enterRuleIndex);  parser.enterRule(cuctx, parser.getState(), enterRuleIndex); com.google.common.collect.RegularImmutableBiMap rulesById = com.google.common.collect.RegularImmutableBiMap.builder().putAll(ruleMap.values()).build(); cuctx.children[0].print();         public static List<Object> get(Object c) { return c.children.select(FunctionUtil.bind("return m -> { Pair.of(m, Arrays.asList(rulesById.get(Reflector.invokeOrDefault(m, \"getRuleIndex\")), Reflector.invokeOrDefault(m, \"getStart\"), Reflector.invokeOrDefault(Reflector.invokeOrDefault(m, \"getStart\"), \"getText\"), Character.toChars(0x0a)[0].toString(), \":\", Reflect.getfldval(m, \"children\", false) != null? Reflect.getfldval(m, \"children\", false): Arrays.asList())); }", "rulesById", rulesById)); };   tdecl = get(cuctx).filter("typeDeclaration").firstOrDefault().getKey(); cdecl = get(tdecl).filter("classDeclaration").firstOrDefault().getKey(); body = get(cdecl).filter("classBody").firstOrDefault().getKey(); (decls = get(body).evalSelect("""m => m.getKey().children.evalSelect("n => n.getText()"); """)).size();



