public static Map dumpDexMethods(Class cls) {

  Map mp = new org.apache.commons.collections4.map.ListOrderedMap(); com.android.dex.Dex dex = org.d6r.ClassInfo.getDex(cls); toc = dex.getTableOfContents(); com.android.dex.ProtoId[] protoids = CollectionUtil.toArray(dex.protoIds()); com.android.dex.MethodId[] methodids = CollectionUtil.toArray(dex.methodIds()); String[] strings = CollectionUtil.toArray(dex.strings()); Integer[] wtypeids = CollectionUtil.toArray(dex.typeIds()); int[] typeids = ArrayUtils.toPrimitive(wtypeids);   cdidx = cls.getDexClassDefIndex(); cd = dex.classDefs()[cdidx]; cdatoffs = cd.getClassDataOffset(); sec = toc.classDatas; s = dex.open(sec.off); pos = s.getPosition(); tgtpos = cdatoffs; skip = tgtpos - pos; s.skip(skip); cdat = s.readClassData(); cdms = cdat.getDirectMethods(); tls = dex.open(pos = toc.typeLists.off); for (int d=0; d<cdms.length; d+=1) { cdm = cdms[d]; midx = cdm.getMethodIndex(); codeoffs = cdm.getCodeOffset(); acc = cdm.getAccessFlags(); mid = methodids[midx]; name = strings[mid.getNameIndex()]; proto = protoids[mid.getProtoIndex()]; rettidx = proto.getReturnTypeIndex(); rettype = DexVisitor.typeToName(strings[typeids[rettidx]]).replace("[]", "\u001b[1;37m[]\u001b[0m");  paroffs = proto.getParametersOffset(); String[]  paramNames = new String[0]; String[] ptypes = new String[0]; if (codeoffs != 0) { codesec = dex.open(toc.codes.off); codesec.skip(codeoffs - codesec.getPosition()); code = codesec.readCode(); dinfoffs = code.getDebugInfoOffset(); if (dinfoffs != 0) { rdr = new DebugReader(dex); rdr.in = dex.open(startpos = toc.debugInfos.off); rdr.in.skip(dinfoffs - startpos); inf = rdr.read(); paramNames = inf.paramNames; }; };  StringBuffer sb = new StringBuilder(); if (paroffs != 0) { if (tls.getPosition() > paroffs) tls = dex.open(toc.typeLists.off); tls.skip(paroffs - tls.getPosition()); ptl = tls.readTypeList();  short[] typeidxs = ptl.getTypes(); ptypes = new String[typeidxs.length]; for (int i=0; i<typeidxs.length; i+=1) { int typeidx = typeidxs[i]; ptypes[i] = DexVisitor.typeToName(strings[typeids[(int)typeidx]]); colortype = ptypes[i].replace("[]", "\u001b[1;37m[]\u001b[0m"); pname = paramNames != null && i < paramNames.length? paramNames[i]: "var"+String.valueOf(i); if (i != 0)  sb.append(", "); sb.append("\u001b[1;32m").append(colortype).append(' ').append("\u001b[0m").append(pname);  }; } else ptypes = new String[0]; System.out.printf("\u001b[1;30m%s\u001b[0m%s\u001b[1;36m%s \u001b[1;33m%s\u001b[0m(\u001b[1;32m%s\u001b[0m);\n", Modifier.toString(acc), acc != 0? " ": "", rettype, name, sb);    };  

  return mp;

}


public static Map dumpDexMethods(Class cls) { Map mp = new org.apache.commons.collections4.map.ListOrderedMap(); com.android.dex.Dex dex = org.d6r.ClassInfo.getDex(cls); toc = dex.getTableOfContents(); com.android.dex.ProtoId[] protoids = CollectionUtil.toArray(dex.protoIds()); com.android.dex.MethodId[] methodids = CollectionUtil.toArray(dex.methodIds()); String[] strings = CollectionUtil.toArray(dex.strings()); Integer[] wtypeids = CollectionUtil.toArray(dex.typeIds()); int[] typeids = ArrayUtils.toPrimitive(wtypeids);   cdidx = cls.getDexClassDefIndex(); cd = dex.classDefs()[cdidx]; cdatoffs = cd.getClassDataOffset(); sec = toc.classDatas; s = dex.open(sec.off); pos = s.getPosition(); tgtpos = cdatoffs; skip = tgtpos - pos; s.skip(skip); cdat = s.readClassData(); cdms = cdat.getDirectMethods(); tls = dex.open(pos = toc.typeLists.off); for (int d=0; d<cdms.length; d+=1) { cdm = cdms[d]; midx = cdm.getMethodIndex(); codeoffs = cdm.getCodeOffset(); acc = cdm.getAccessFlags(); mid = methodids[midx]; name = strings[mid.getNameIndex()]; proto = protoids[mid.getProtoIndex()]; rettidx = proto.getReturnTypeIndex(); rettype = DexVisitor.typeToName(strings[typeids[rettidx]]).replace("[]", "\u001b[1;37m[]\u001b[0m");  paroffs = proto.getParametersOffset(); String[]  paramNames = new String[0]; String[] ptypes = new String[0]; if (codeoffs != 0) { codesec = dex.open(toc.codes.off); codesec.skip(codeoffs - codesec.getPosition()); code = codesec.readCode(); dinfoffs = code.getDebugInfoOffset(); if (dinfoffs != 0) { rdr = new DebugReader(dex); rdr.in = dex.open(startpos = toc.debugInfos.off); rdr.in.skip(dinfoffs - startpos); inf = rdr.read(); paramNames = inf.paramNames; }; };  StringBuffer sb = new StringBuilder(); if (paroffs != 0) { if (tls.getPosition() > paroffs) tls = dex.open(toc.typeLists.off); tls.skip(paroffs - tls.getPosition()); ptl = tls.readTypeList();  short[] typeidxs = ptl.getTypes(); ptypes = new String[typeidxs.length]; for (int i=0; i<typeidxs.length; i+=1) { int typeidx = typeidxs[i]; ptypes[i] = DexVisitor.typeToName(strings[typeids[(int)typeidx]]); colortype = ptypes[i].replace("[]", "\u001b[1;37m[]\u001b[0m"); pname = paramNames != null  && i < paramNames.length? paramNames[i]: "var"+String.valueOf(i); if (i != 0)  sb.append(", "); sb.append("\u001b[1;32m").append(colortype).append(' ').append("\u001b[0m").append(pname);  }; } else ptypes = new String[0]; System.out.printf("\u001b[1;30m%s\u001b[0m%s\u001b[1;36m%s \u001b[1;33m%s\u001b[0m(\u001b[1;32m%s\u001b[0m);\n", Modifier.toString(acc), acc != 0? " ": "", rettype, name, sb);  mp.put(sb.toString(), Pair.of(rdr, inf));  }; return mp; }

