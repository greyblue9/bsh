import java.util.Map.Entry;


















public static Map generateResClasses(String path) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; ZipFile zf = new ZipFile(path); ZipEntry ze = zf.getEntry("resources.arsc"); System.err.printf("Found ZipEntry: '%s'\n", ze.getName()); InputStream is = zf.getInputStream(ze); System.err.printf("Parsing ARSC data...\n"); ARSCData data = ARSCDecoder.decode( is, findFlagsOffsets = true, keepBroken = true ); Object resPkg = data.mPackages[0]; String pkg = resPkg.getName(); Map mRes = null; System.err.printf("Found %d resources\n", (mRes = resPkg.mConfigs.entrySet()[0].getValue().mResources).size()); Map bytype = new TreeMap(); for (Entry entry: mRes.entrySet()) { int intValue = entry.getKey().mId.id; String name = entry.getKey().mName.replaceAll("[^a-zA-Z0-9_$]", "_"); String type = entry.getKey().getType().getName(); Map map = bytype.get(type); if (map == null) { map = new TreeMap(); bytype.put(type, map); System.err.println(type); }; map.put(intValue, name); }; CtClass rct = new CtNewClass(String.format("%s.R", pkg), CollectionUtil.getClassPool(), false, CollectionUtil.getClassPool().get("java.lang.Object")); ctcs = new HashSet(); ctcs.add(rct); for (Entry entry: bytype.entrySet()) { String type = entry.getKey(); String className = String.format("%s.R$%s", pkg, type); CtClass ct = rct.makeNestedClass(className, true); ctcs.add(ct); for (Entry item: entry.getValue().entrySet()) { if (ct.getField2(item.getValue(), "I") != null) continue; CtField cf = new CtField(CtClass.intType, item.getValue(), ct); cf.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL); javassist.CtField.Initializer init = javassist.CtField.Initializer.constant((int) item.getKey().intValue()); ct.addField(cf, init); System.err.println(cf); }; }; Map zm = new TreeMap(); for (CtClass ct: ctcs) { byte[] bc = toBytecode(ct); zm.put(ClassInfo.classNameToPath(ct.getName(), "class"), bc); System.err.printf("%s (%d bytes)\n", ct.getName(), bc.length); }; return zm; };


















public static Map generateResClasses(byte[] apkBytes) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; Map apkParts = getApkParts(apkBytes); byte[] arscBytes = apkParts.get("resources.arsc"); InputStream is = new ByteArrayInputStream(arscBytes); System.err.printf("Parsing ARSC data...\n"); return generateResClasses(is); };















public static Map generateResClasses(InputStream arscInputStream) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; ARSCData data = ARSCDecoder.decode( is, findFlagsOffsets = true, keepBroken = true ); Object resPkg = data.mPackages[0]; String pkg = resPkg.getName(); Map mRes = null; System.err.printf("Found %d resources\n", (mRes = resPkg.mConfigs.entrySet()[0].getValue().mResources).size()); Map bytype = new TreeMap(); for (Entry entry: mRes.entrySet()) { int intValue = entry.getKey().mId.id; String name = entry.getKey().mName.replaceAll("[^a-zA-Z0-9_$]", "_"); String type = entry.getKey().getType().getName(); Map map = bytype.get(type); if (map == null) { map = new TreeMap(); bytype.put(type, map); System.err.println(type); }; map.put(intValue, name); }; CtClass rct = new CtNewClass(String.format("%s.R", pkg), CollectionUtil.getClassPool(), false, CollectionUtil.getClassPool().get("java.lang.Object")); ctcs = new HashSet(); ctcs.add(rct); for (Entry entry: bytype.entrySet()) { String type = entry.getKey(); String className = String.format("%s.R$%s", pkg, type); CtClass ct = rct.makeNestedClass(className, true); ctcs.add(ct); for (Entry item: entry.getValue().entrySet()) { if (ct.getField2(item.getValue(), "I") != null) continue; CtField cf = new CtField(CtClass.intType, item.getValue(), ct); cf.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL); javassist.CtField.Initializer init = javassist.CtField.Initializer.constant((int) item.getKey().intValue()); ct.addField(cf, init); System.err.println(cf); }; }; Map zm = new TreeMap(); for (CtClass ct: ctcs) { byte[] bc = toBytecode(ct); zm.put(ClassInfo.classNameToPath(ct.getName(), "class"), bc); System.err.printf("%s (%d bytes)\n", ct.getName(), bc.length); }; return zm; };












public static Map generateResClasses(InputStream arscInputStream) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; ARSCData data = ARSCDecoder.decode(arscInputStream, findFlagsOffsets = true, keepBroken = true ); Object resPkg = data.mPackages[0]; String pkg = resPkg.getName(); Map mRes = null; System.err.printf("Found %d resources\n", (mRes = resPkg.mConfigs.entrySet()[0].getValue().mResources).size()); Map bytype = new TreeMap(); for (Entry entry: mRes.entrySet()) { int intValue = entry.getKey().mId.id; String name = entry.getKey().mName.replaceAll("[^a-zA-Z0-9_$]", "_"); String type = entry.getKey().getType().getName(); Map map = bytype.get(type); if (map == null) { map = new TreeMap(); bytype.put(type, map); System.err.println(type); }; map.put(intValue, name); }; CtClass rct = new CtNewClass(String.format("%s.R", pkg), CollectionUtil.getClassPool(), false, CollectionUtil.getClassPool().get("java.lang.Object")); ctcs = new HashSet(); ctcs.add(rct); for (Entry entry: bytype.entrySet()) { String type = entry.getKey(); String className = String.format("%s.R$%s", pkg, type); CtClass ct = rct.makeNestedClass(className, true); ctcs.add(ct); for (Entry item: entry.getValue().entrySet()) { if (ct.getField2(item.getValue(), "I") != null) continue; CtField cf = new CtField(CtClass.intType, item.getValue(), ct); cf.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL); javassist.CtField.Initializer init = javassist.CtField.Initializer.constant((int) item.getKey().intValue()); ct.addField(cf, init); System.err.println(cf); }; }; Map zm = new TreeMap(); for (CtClass ct: ctcs) { byte[] bc = toBytecode(ct); zm.put(ClassInfo.classNameToPath(ct.getName(), "class"), bc); System.err.printf("%s (%d bytes)\n", ct.getName(), bc.length); }; return zm; };









public static Map generateResClasses(InputStream arscInputStream) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; ARSCData data = ARSCDecoder.decode(arscInputStream, findFlagsOffsets = true, keepBroken = true ); Object resPkg = data.mPackages[0]; String pkg = resPkg.getName(); Map mRes = null; System.err.printf("Found %d resources\n", (mRes = resPkg.mConfigs.entrySet()[0].getValue().mResources).size()); Map bytype = new TreeMap(); for (Entry entry: mRes.entrySet()) { int intValue = entry.getKey().mId.id; String name = entry.getKey().mName.replaceAll("[^a-zA-Z0-9_$]", "_"); String type = entry.getKey().getType().getName(); Map map = bytype.get(type); if (map == null) { map = new TreeMap(); bytype.put(type, map); System.err.println(type); }; map.put(intValue, name); }; CtClass rct = new CtNewClass(String.format("%s.R", pkg), CollectionUtil.getClassPool(), false, CollectionUtil.getClassPool().get("java.lang.Object")); ctcs = new HashSet(); ctcs.add(rct); for (Entry entry: bytype.entrySet()) { String type = entry.getKey(); String className = String.format("%s.R$%s", pkg, type); CtClass ct = rct.makeNestedClass(className, true); ctcs.add(ct); for (Entry item: entry.getValue().entrySet()) { if (ct.getField2(item.getValue(), "I") != null) continue; CtField cf = new CtField(CtClass.intType, item.getValue(), ct); cf.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL); javassist.CtField.Initializer init = javassist.CtField.Initializer.constant((int) item.getKey().intValue()); ct.addField(cf, init); System.err.println(cf); }; }; Map zm = new TreeMap(); for (CtClass ct: ctcs) { byte[] bc = toBytecode(ct); zm.put(ClassInfo.classNameToPath(ct.getName(), "class"), bc); System.err.printf("%s (%d bytes)\n", ct.getName(), bc.length); }; return zm; };






public static Map generateResClasses(InputStream arscInputStream) { import brut.androlib.res.decoder.ARSCDecoder; import brut.androlib.res.decoder.ARSCDecoder.ARSCData; import brut.androlib.res.data.ResValuesFile; import brut.androlib.res.data.ResPackage; ARSCData data = ARSCDecoder.decode(arscInputStream, findFlagsOffsets = true, keepBroken = true ); Object resPkg = data.mPackages[0]; String pkg = resPkg.getName(); Map mRes = null; System.err.printf("Found %d resources\n", (mRes = resPkg.mConfigs.entrySet()[0].getValue().mResources).size()); Map bytype = new TreeMap(); for (Entry entry: mRes.entrySet()) { int intValue = entry.getKey().mId.id; String name = entry.getKey().mName.replaceAll("[^a-zA-Z0-9_$]", "_"); String type = entry.getKey().getType().getName(); Map map = bytype.get(type); if (map == null) { map = new TreeMap(); bytype.put(type, map); System.err.println(type); }; map.put(intValue, name); }; CtClass rct = new CtNewClass(String.format("%s.R", pkg), CollectionUtil.getClassPool(), false, CollectionUtil.getClassPool().get("java.lang.Object")); ctcs = new HashSet(); ctcs.add(rct); for (Entry entry: bytype.entrySet()) { String type = entry.getKey(); String className = String.format("%2$s" /*"s.R$%s"*/ ,  pkg, type); CtClass ct = rct.makeNestedClass(entry.getKey(), true); ctcs.add(ct); for (Entry item: entry.getValue().entrySet()) { if (ct.getField2(item.getValue(), "I") != null) continue; CtField cf = new CtField(CtClass.intType, item.getValue(), ct); cf.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL); javassist.CtField.Initializer init = javassist.CtField.Initializer.constant((int) item.getKey().intValue()); ct.addField(cf, init); System.err.println(cf); }; }; Map zm = new TreeMap(); for (CtClass ct: ctcs) { byte[] bc = toBytecode(ct); zm.put(ClassInfo.classNameToPath(ct.getName(), "class"), bc); System.err.printf("%s (%d bytes)\n", ct.getName(), bc.length); }; return zm; };



