

public static String[] getClinitClassNames(Dex dex) { com.android.dex.MethodId[] mids = CollectionUtil.toArray(dex.methodIds().filter("<clinit>")); String[] clinitClassNames = ClassInfo.typeToName(mids.select(FunctionUtil.bind("return m -> { dex.typeNames()[m.getDeclaringClassIndex()]; }", "dex", dex)));  return clinitClassNames; }

public static String[] getClinitClassNames(String dexPath) { Object dexElement = ClassPathUtil2.findDexElement(Thread.currentThread().getContextClassLoader(), new File(dexPath)); byte[] b = null; if (de != null) { de.maybeInit(); b=IOUtils.toByteArray(new org.apache.commons.io.input.AutoCloseInputStream(ZipUtil.toInputStream(de.zipFile))); } else { b = ZipUtil.toByteArray(new File(dexPath), "classes.dex"); }; return getClinitClassNames(b); }

public static String[] getClinitClassNames(byte[] zipOrDexBytes) { boolean isZip = (zipOrDexBytes[0] == (byte)'P' && zipOrDexBytes[1] == (byte)'K'); byte[] dexBytes = (isZip)? ZipUtil.toByteArray(zipOrDexBytes, "classes.dex"): zipOrDexBytes; Dex dex = new Dex(dexBytes); return getClinitClassNames(dex); }



public static String[] getClinitClassNames(File loadedDexFilePath) { String[] strs = null; Object dexElement = ClassPathUtil2.findDexElement(Thread.currentThread().getContextClassLoader(), loadedDexFilePath); if (dexElement == null)  throw new IllegalArgumentException(String.format("Cannot find a loaded DexElement with a path matching the File \"%s\"", loadedDexFilePath)); Integer mCookie = dexElement.dexFile.mCookie; Dex dex = null; int index = 0;  String[] classNames = DexFile.getClassNameList(mCookie); boolean found = false; for (int i=0,len=classNames.length; i<len; ++i) { try {Class cls = Class.classForName(classNames[i], false, Thread.currentThread().getContextClassLoader()); if (cls != null) { dex = org.d6r.ClassInfo.getDex(cls); if (dex == null) { System.err.printf("classForName(%s).getDex() returned null\n", classNames[i]); continue; }; } else { System.err.printf("classForName(%s) returned null\n", classNames[i]); continue;  }; } catch (Throwable e) { continue; };  if (ClassInfo.typeToName(dex.strings()[dex.typeIds()[dex.open(dex.getTableOfContents().classDefs.off).readClassDef().getTypeIndex()]]).equals(classNames[0])) { found = true; break; } }; if (found) System.err.printf("** Found matching Dex for DexElement: [%s] **\n", dexElement); else throw new RuntimeException(String.format("Matching dex not found for DexElement: [%s]; mCookie = %d", dexElement, mCookie)); strs = CollectionUtil.toArray(dex.strings()); int methodName_sidx = Arrays.binarySearch(strs, "<clinit>");  Integer[] typeIds = ArrayUtils.nullToEmpty(new HashSet(dex.methodIds().select(String.format("m => return (java.lang.Integer) ((m.getNameIndex() == %d)? java.lang.Integer#valueOf(m.getDeclaringClassIndex()): null); }", methodName_sidx))).toArray(new Integer[0]));  String[] typeNames = ClassInfo.typeToName(typeIds.select(FunctionUtil.bind("return m -> { m != null? strs[dex.typeIds().get(m.intValue())]: null; }", "strs", strs,"dex",dex))); }

