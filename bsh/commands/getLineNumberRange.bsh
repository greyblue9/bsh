
public static Range<Integer> getLineNumberRange(Member mtd) { DexParser.DebugInfo pi = DexParser.parseDebugInfo(mtd); TreeSet<Integer> ts = new TreeSet<Integer>(); ts.addAll(pi.lineNumberTable.entries().values()); int[] lineNos = ArrayUtils.toPrimitive(ts.toArray(new Integer[0])); int lineStart = lineNos.length != 0? lineNos[0]: 0; int lineEnd = lineNos.length != 0? lineNos[lineNos.length-1]: 0; Range<Integer> lineRange = Range.closed(Integer.valueOf(lineStart), Integer.valueOf(lineEnd)); return lineRange; };

public static SortedMap getLineNumberRange(Class cls) { Constructor[] ctors = cls.getDeclaredConstructors(); Method[] mtds = cls.getDeclaredMethods(); Method clinit = null; try { clinit = Reflect.getDeclaredConstructorOrMethod(cls, "<clinit>", new Class[0]); if (clinit != null) { mtds = ArrayUtils.addAll(new Method[]{ clinit }, mtds); System.err.printf("got clinit (static initializer) method: %s\n", clinit); } } catch (Throwable e) {;  }; List<Member> all = new ArrayList(Iterables.concat(Arrays.asList(Arrays.asList(ctors), Arrays.asList(mtds)).toArray(new Iterable[0])).toList()); for (Iterator it = all.iterator(); it.hasNext();) { Member mb = it.next();   int acc = mb.getModifiers();  if ((acc & Modifier.SYNTHETIC) != 0 || (acc & Modifier.ABSTRACT) != 0 || (acc & Modifier.NATIVE) != 0) it.remove(); };    Map byRange = new TreeMap(); for (Member mb: all) { Range lineRange = getLineNumberRange(mb); System.err.printf("(%5d - %5d): %s\n", lineRange.lowerEndpoint(), lineRange.upperEndpoint(), dumpMembers.colorize(mb));  byRange.put(lineRange, mb); }; return byRange;  };
