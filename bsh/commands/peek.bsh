
public static byte[] peek(InputStream is, int count, boolean allowConsume) { byte[] b = null; if (is.markSupported()) { b = new byte[count]; is.mark(count); com.google.common.io.ByteStreams.readFully(is, b, 0, count); is.reset(); } else if (is instanceof FileInputStream) { b = new byte[count]; java.nio.channels.FileChannel ch = ((FileInputStream) is).getChannel(); long origPos = ch.position(); com.google.common.io.ByteStreams.readFully(is, b, 0, count); ch.position(origPos); } else { Collection zfs = Reflect.searchObject(is, ZipFile.class, false, 0, 4); Iterator it = zfs.iterator(); if (it.hasNext()) { ZipFile zf = it.next(); InputStream sis = ZipUtil.toInputStream(zf); com.google.common.io.ByteStreams.readFully(sis, b = new byte[count], 0, count); sis.close(); return b; }; Collection chs = Reflect.searchObject(is, java.nio.channels.Channel.class, false, 0, 4); Iterator it = chs.iterator(); if (it.hasNext()) { java.nio.channels.FileChannel ch = it.next(); FileDescriptor fd = PosixUtil.dup(ch.getFD()); long origPos = ch.position(); ch.position(0); FileInputStream fis = new FileInputStream(fd); com.google.common.io.ByteStreams.readFully(fis, b, 0, count); ch.position(origPos); System.err.println(ch.getFD()); System.err.println(fd); fis.close(); System.err.println(ch.getFD()); System.err.println(fd); return b; };     if (! allowConsume) { throw new UnsupportedOperationException(String.format("Cannot peek() at %s: stream must either support mark(), provide a getChannel() method that returns a seekable ByteChannel, or provide a getFD() method (where the open file descriptor supports lseek()).", is)); }; b = new byte[count]; com.google.common.io.ByteStreams.readFully(is, b, 0, count); }; return b; };

